{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Kondor-JSON","text":"<p>Welcome to Kondor-JSON, a Kotlin-first JSON serialization library that emphasizes type-safety, composability, and clarity.</p>"},{"location":"#what-is-kondor-json","title":"\ud83d\udd0d What is Kondor-JSON?","text":"<p>Kondor-JSON allows you to define type-safe, bidirectional mappings between your Kotlin data classes and JSON documents using a flexible DSL. It avoids reflection and favors a functional style to keep your data transformations explicit and testable.</p>"},{"location":"#features","title":"\ud83d\ude80 Features","text":"<ul> <li>Type-safe JSON serialization/deserialization</li> <li>Fully customizable converters</li> <li>Versioned converters for backward compatibility</li> <li>String representable support for enums and sealed classes</li> <li>No reflection, works in Kotlin Multiplatform</li> </ul>"},{"location":"#example","title":"\ud83d\udee0\ufe0f Example","text":"<pre><code>import com.ubertob.kondor.json.*\nimport com.ubertob.kondor.json.jvalue.*\n\ndata class Person(val name: String, val age: Int)\n\nobject PersonConverter : JConverterObject&lt;Person&gt;() {\n    private val name by str()\n    private val age by int()\n\n    override fun JsonNodeObject.deserializeOrThrow(): Person =\n        Person(\n            name = +name,\n            age = +age\n        )\n\n    override fun Person.serialize(): JsonNodeObject =\n        jsonObj {\n            name of it.name\n            age of it.age\n        }\n}\n\nfun main() {\n    val person = Person(\"Alice\", 30)\n    val json = PersonConverter.toJsonStr(person)\n    println(json)\n    println(PersonConverter.fromJsonStr(json))\n}\n</code></pre>"},{"location":"#whats-next","title":"\ud83d\udccc What's Next?","text":"<p>Explore more of Kondor\u2019s features:</p> <ul> <li>\ud83d\udcbb Converters Overview \u2013 an overview understanding how to work with Kondor converters</li> <li>\ud83d\udd01 Versioning the JSON \u2013 for evolving schemas</li> <li>\ud83d\udd24 Tiny Types (Value Objects) \u2013 for handling object you want to represent as a string or number</li> <li>\ud83d\udd24 Enums and Sealed Classes \u2013 for working with enums and sealed classes</li> <li>\ud83d\udee0 Field Functions \u2013 helper functions for defining fields in Kondor converters</li> <li>\ud83e\uddf3 Sealed Classes and Polymorphic JSON \u2013 handling polymorphic JSON with sealed classes</li> </ul>"},{"location":"enums-and-sealed/","title":"Enums and Sealed Classes","text":"<p>Kondor-JSON offers seamless support for Kotlin enums, providing both a default serialization strategy and the ability to customize the behavior using <code>JEnumClass</code>.</p>"},{"location":"enums-and-sealed/#enums","title":"\ud83d\udd24 Enums","text":""},{"location":"enums-and-sealed/#default-enum-serialization","title":"Default Enum Serialization","text":"<p>The easiest way to serialize an enum in Kondor is by using <code>JEnumClass</code>, which provides a sensible default: enum values are mapped to their <code>.name</code> strings in JSON.</p> <pre><code>enum class Colour { Red, Green, Blue }\n\nobject JColour : JEnumClass&lt;Colour&gt;(Colour::class)\n</code></pre> <p>You can then use this converter in your data classes:</p> <pre><code>data class Paint(val shade: Colour)\n\nobject JPaint : JAny&lt;Paint&gt;() {\n    val shade by JColour(Paint::shade)\n\n    override fun JsonNodeObject.deserializeOrThrow() =\n        Paint(+shade)\n}\n</code></pre> <p>This will serialize a <code>Paint</code> object to:</p> <pre><code>{ \"shade\": \"Red\" }\n</code></pre>"},{"location":"enums-and-sealed/#customizing-enum-representation","title":"Customizing Enum Representation","text":"<p>If you'd like to represent enums using custom strings (e.g., abbreviations), you can subclass <code>JEnumClass</code> and override the <code>render</code> and <code>cons</code> methods.</p> <pre><code>enum class Status { Active, Inactive, Pending }\n\nobject JStatus : JEnumClass&lt;Status&gt;(Status::class) {\n    override val render: (Status) -&gt; String = {\n        when (it) {\n            Status.Active -&gt; \"A\"\n            Status.Inactive -&gt; \"I\"\n            Status.Pending -&gt; \"P\"\n        }\n    }\n\n    override val cons: (String) -&gt; Status = {\n        when (it) {\n            \"A\", \"Active\" -&gt; Status.Active\n            \"I\", \"Inactive\" -&gt; Status.Inactive\n            \"P\", \"Pending\" -&gt; Status.Pending\n            else -&gt; error(\"Unknown status: $it\")\n        }\n    }\n}\n</code></pre> <p>This allows the following round-trip:</p> <pre><code>{ \"status\": \"A\" }\n</code></pre> <p>It also enables backwards compatibility with older JSON representations. For example, if earlier versions of your application used full enum names like \"Active\", and you've now switched to abbreviations like \"A\", the <code>cons</code> function can support both:</p> <ul> <li>\"Active\" and \"A\" will both deserialize to <code>Status.Active</code></li> <li>\"Inactive\" and \"I\" to <code>Status.Inactive</code></li> <li>\"Pending\" and \"P\" to <code>Status.Pending</code></li> </ul> <p>This makes it easy to evolve your enum serialization format over time without breaking compatibility with existing data.</p> <p>The custom converter can now be used just like any other in a <code>JAny</code> definition.</p>"},{"location":"enums-and-sealed/#sealed-classes","title":"\ud83e\uddf1 Sealed Classes","text":"<p>Kondor makes it easy to work with sealed class hierarchies by using the <code>JSealed</code> converter. This allows you to encode and decode subclasses with a discriminator field that indicates which type is being used.</p>"},{"location":"enums-and-sealed/#example","title":"Example","text":"<pre><code>sealed class Animal\n\ndata class Dog(val name: String) : Animal()\ndata class Cat(val lives: Int) : Animal()\n</code></pre> <p>You define converters for each concrete subclass:</p> <pre><code>object JDog : JAny&lt;Dog&gt;() {\n    val name by str(Dog::name)\n\n    override fun JsonNodeObject.deserializeOrThrow() =\n        Dog(+name)\n}\n\nobject JCat : JAny&lt;Cat&gt;() {\n    val lives by num(Cat::lives)\n\n    override fun JsonNodeObject.deserializeOrThrow() =\n        Cat(+lives)\n}\n</code></pre> <p>Then, define a <code>JSealed</code> converter for the sealed class. To do this, you need to override two things:</p> <ol> <li><code>extractTypeName(obj: T)</code>: a function that returns a string discriminator based on the type of the object.</li> <li><code>subConverters</code>: a map that links type names to their respective converters.</li> </ol> <pre><code>object JAnimal : JSealed&lt;Animal&gt;() {\n    override fun extractTypeName(obj: Animal): String = when (obj) {\n        is Dog -&gt; \"dog\"\n        is Cat -&gt; \"cat\"\n    }\n\n    override val subConverters: Map&lt;String, ObjectNodeConverter&lt;out Animal&gt;&gt; = mapOf(\n        \"dog\" to JDog,\n        \"cat\" to JCat\n    )\n}\n</code></pre> <p>This will produce JSON like:</p> <pre><code>{ \"_type\": \"dog\", \"name\": \"Fido\" }\n</code></pre> <p>When deserializing, Kondor uses the value of the <code>\"_type\"</code> property to determine which converter to use. This makes sealed class hierarchies both extensible and safe to work with in a polymorphic way.</p> <p>By default, the discriminator property is named <code>_type</code>, but you can customize this by overriding:</p> <pre><code>override val discriminatorFieldName: String = \"type\"\n</code></pre> <p>As with enums, you can also map multiple different type strings to the same converter. This allows older JSON data to remain compatible even after renaming or restructuring the Kotlin class hierarchy. For instance:</p> <pre><code>override val subConverters = mapOf(\n    \"dog\" to JDog,\n    \"canine\" to JDog, // legacy support\n    \"cat\" to JCat\n)\n</code></pre> <p>This means both <code>{ \"_type\": \"dog\" }</code> and <code>{ \"_type\": \"canine\" }</code> will deserialize using <code>JDog</code>. This makes it easier to evolve sealed class hierarchies over time without breaking old clients.</p>"},{"location":"enums-and-sealed/#whats-next","title":"\ud83d\udccc What's Next?","text":"<p>Explore more of Kondor\u2019s features:</p> <ul> <li>\ud83d\udcbb Converters Overview \u2013 an overview understanding how to work with Kondor converters</li> <li>\ud83d\udd01 Versioning the JSON \u2013 for evolving schemas</li> <li>\ud83d\udd24 Tiny Types (Value Objects) \u2013 for handling object you want to represent as a string or number</li> <li>\ud83d\udd24 Enums and Sealed Classes \u2013 for working with enums and sealed classes</li> <li>\ud83d\udee0 Field Functions \u2013 helper functions for defining fields in Kondor converters</li> <li>\ud83e\uddf3 Sealed Classes and Polymorphic JSON \u2013 handling polymorphic JSON with sealed classes</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to Kondor-JSON! This guide will help you get up and running quickly, and explain the core concepts that make Kondor-JSON unique.</p>"},{"location":"getting-started/#installation","title":"\ud83d\udd27 Installation","text":"<p>Add Kondor-JSON to your <code>build.gradle.kts</code>:</p> <pre><code>dependencies {\n    implementation(\"com.ubertob.kondor:kondor-json:&lt;latest-version&gt;\")\n}\n</code></pre> <p>\ud83d\udce6 Check Maven Central for the latest version.</p>"},{"location":"getting-started/#core-concept","title":"\ud83c\udfaf Core Concept","text":"<p>Unlike many serialization libraries, Kondor-JSON does not use intermediate DTOs. Instead, you define a single, bidirectional converter that maps your Kotlin type directly to and from JSON using <code>JConverter</code>.</p> <p>Kondor internally represents JSON objects using a type called <code>JsonNodeObject</code>. This is a tree-like structure that mirrors JSON syntax.</p> <p>Most of the time, you don\u2019t need to interact with *``* directly**\u2014the DSL handles it for you via field bindings and converters.</p> <p>Each converter is responsible for:</p> <ul> <li>Parsing a <code>JsonNodeObject</code> into your type (<code>deserializeOrThrow</code>)</li> <li>Serializing your type into a <code>JsonNodeObject</code> (default via DSL delegates, or override if needed)</li> </ul>"},{"location":"getting-started/#example-using-jany-with-the-kondor-dsl","title":"\u2728 Example: Using <code>JAny</code> with the Kondor DSL","text":"<p>Let\u2019s define a <code>Person</code> class and create a converter by extending <code>JAny&lt;Person&gt;</code>. We'll use Kondor\u2019s DSL-style field delegates to map each property, and take advantage of the <code>+</code> bind operator for clean deserialization.</p> <pre><code>import com.ubertob.kondor.json.*\nimport com.ubertob.kondor.json.jvalue.*\n\ndata class Person(val name: String, val age: Int)\n\nobject PersonConverter : JAny&lt;Person&gt;() {\n    val name by str(Person::name)\n    val age by num(Person::age)\n\n    override fun JsonNodeObject.deserializeOrThrow(): Person =\n        Person(\n            name = +name,\n            age = +age\n        )\n}\n</code></pre> <p>This pattern offers a clean and expressive way to map fields.</p> <p>\ud83d\udcdd Convention Note: While we\u2019ve named our converter <code>PersonConverter</code> here, it\u2019s common in Kondor projects to use a shorter name like <code>JPerson</code>. This saves typing without sacrificing clarity\u2014but you\u2019re free to choose whatever naming style fits your project best.</p>"},{"location":"getting-started/#usage","title":"\ud83e\uddea Usage","text":"<pre><code>fun main() {\n    val person = Person(\"Alice\", 30)\n    val json = PersonConverter.toJson(person)\n    println(json) // {\"name\":\"Alice\",\"age\":30}\n\n    val parsed = PersonConverter.fromJson(json)\n    println(parsed) // Person(name=Alice, age=30)\n}\n</code></pre>"},{"location":"getting-started/#whats-going-on","title":"\ud83e\udde0 What's Going On?","text":""},{"location":"getting-started/#what-is-jany","title":"\ud83d\udce6 What is JAny?","text":"<p><code>JAny&lt;T&gt;</code> is the top-level abstraction in the Kondor DSL for converting objects. It is the class you will use most often when working with Kondor.</p> <p>You define a subclass of <code>JAny</code> for each type you want to serialize, and use the DSL to declare how its properties map to and from JSON.</p> <p>This allows you to skip intermediate DTOs and instead declare the full serialization contract in one place.</p>"},{"location":"getting-started/#defining-fields","title":"\ud83d\udd11 Defining Fields","text":"<p>We start by defining fields using the DSL delegates like <code>str</code> and <code>num</code>. These fields form the shape of the JSON representation.</p> <p>The names you give these fields in your converter directly become the property names in the serialized JSON object.</p> <p>For example, in the converter we define <code>val name by str(Person::name)</code>, so the resulting JSON will include a property named <code>\"name\"</code>. If you changed this to <code>val fullName by str(Person::name)</code>, the output JSON would have <code>\"fullName\"</code> instead.</p>"},{"location":"getting-started/#how-fields-work","title":"\ud83e\udde9 How Fields Work","text":"<p>This section explains how basic field mapping works using the DSL.</p> <p>The functions <code>str</code> and <code>num</code> are part of Kondor\u2019s DSL for defining fields. They each take arguments that describe how to serialize and deserialize the values:</p> <ul> <li><code>str(Person::name)</code> means \"this field maps to a JSON string, and we get its value from the <code>name</code> property of the <code>Person</code> object.\"</li> <li><code>num(Person::age)</code> similarly maps the <code>age</code> field to a JSON number, pulling it from the <code>age</code> property of <code>Person</code>.</li> </ul> <p>In many cases, these mappings can be inferred automatically\u2014for instance, Kotlin <code>String</code> to JSON string is a direct mapping. But we still need to tell Kondor which property of the object we are talking about\u2014hence the use of property references like <code>Person::name</code>.</p> <p>We'll cover more complex examples later, including how to handle custom types, nullable fields, and schema evolution.</p>"},{"location":"getting-started/#the-bind-operator","title":"\u2795 The Bind Operator","text":"<p>We use the <code>+</code> operator (also known as the bind operator) to extract values from the <code>JsonNodeObject</code>.</p> <p>For example:</p> <pre><code>name = +name\n</code></pre> <p>This line binds the value of the JSON <code>\"name\"</code> field (as defined by the delegate) into the <code>name</code> property of the <code>Person</code> object.</p>"},{"location":"getting-started/#whats-next","title":"\ud83d\udccc What's Next?","text":"<p>Once you're comfortable with this approach, explore more advanced features:</p> <ul> <li>\ud83d\udcbb Converters Overview \u2013 an overview understanding how to work with Kondor converters</li> <li>\ud83d\udd01 Versioning the JSON \u2013 for evolving schemas</li> <li>\ud83d\udd24 Tiny Types (Value Objects) \u2013 for handling object you want to represent as a string or number</li> <li>\ud83d\udd24 Enums and Sealed Classes \u2013 for working with enums and sealed classes</li> <li>\ud83d\udee0 Field Functions \u2013 helper functions for defining fields in Kondor converters</li> <li>\ud83e\uddf3 Sealed Classes and Polymorphic JSON \u2013 handling polymorphic JSON with sealed classes</li> </ul>"},{"location":"getting-started/#key-takeaways","title":"\ud83d\udcd8 Key Takeaways","text":"<ul> <li>\ud83d\udeab Kondor doesn't rely on intermediate DTOs. Instead, you define mapping functions that convert to and from JSON directly.</li> <li>\ud83e\udd16 Much of the mapping logic is inferred automatically by the Kondor DSL.</li> <li>\ud83d\udce6 If you're unsure what kind of converter to use, <code>JAny</code> is likely the one you need\u2014it's the most commonly used abstraction in the DSL.</li> </ul>"},{"location":"short-field-functions/","title":"Field Functions","text":"<p>When defining a converter in Kondor using <code>JAny</code>, you'll typically use one of a set of helper functions to define each field.</p> <p>These helper functions are named after the JSON type you're mapping to \u2013 like <code>str</code> for strings, <code>num</code> for numbers, and so on.</p> <p>Each function takes at least one argument: a property accessor (like <code>User::email</code>) that tells Kondor which field to serialize.</p> <p>Optionally, you can provide a converter as the first argument \u2014 for example, if you're wrapping a field in a tiny type or using a custom format. This gives you flexibility to encode domain-specific types or legacy formats cleanly.</p> <p>Here are the most commonly used field functions:</p>"},{"location":"short-field-functions/#str","title":"<code>str</code>","text":"<p>Use <code>str</code> to map a Kotlin <code>String</code> property to a JSON string field.</p> <pre><code>val name by str(Person::name)\n</code></pre> <p>If you're using a string-based tiny type (like <code>Email</code>), pass its converter in as the first argument:</p> <pre><code>val email by str(JEmail, User::email)\n</code></pre>"},{"location":"short-field-functions/#num","title":"<code>num</code>","text":"<p>Use <code>num</code> to map numeric Kotlin types (<code>Int</code>, <code>Long</code>, <code>Double</code>, etc.) to JSON number fields.</p> <pre><code>val age by num(Person::age)\n</code></pre> <p>If you're wrapping numeric types in tiny types, pass a custom converter first:</p> <pre><code>val score by num(JScore, Player::score)\n</code></pre>"},{"location":"short-field-functions/#bool","title":"<code>bool</code>","text":"<p>Use <code>bool</code> to map a Kotlin <code>Boolean</code> property to a JSON boolean field.</p> <pre><code>val isActive by bool(User::isActive)\n</code></pre> <p>You can pass in a converter if you've wrapped the boolean in a tiny type:</p> <pre><code>val termsAccepted by bool(JTermsAccepted, SignupForm::termsAccepted)\n</code></pre>"},{"location":"short-field-functions/#array","title":"<code>array</code>","text":"<p>Use <code>array</code> to map collections (like <code>List</code> or <code>Set</code>) of other types to JSON arrays. You'll need to provide a converter for the element type.</p> <pre><code>val tags by array(JString, Article::tags)\n</code></pre> <p>This works for both <code>List&lt;T&gt;</code> and <code>Set&lt;T&gt;</code>.</p>"},{"location":"short-field-functions/#obj","title":"<code>obj</code>","text":"<p>Finally, we use <code>obj</code> to map a property that is another object (i.e. a nested data class) to a JSON object field. You'll need to provide a converter for the nested type.</p> <pre><code>val address by obj(JAddress, User::address)\n</code></pre> <p>These field helper functions form the foundation of how you describe the structure of your JSON in Kondor. With just a few of these, you can map most of your data models clearly and concisely.</p> <p>There\u2019s also one more field builder function available: <code>flatten</code>. This is used when you need to inline or \"flatten\" the fields of a nested object directly into the parent object\u2019s JSON structure. We\u2019ll look at how and when to use this in a separate part of the documentation.</p>"},{"location":"short-field-functions/#summary-table","title":"Summary Table","text":"Function Kotlin Type JSON Type Notes <code>str</code> <code>String</code> string Direct string mapping. Use converter for wrapped types. <code>num</code> <code>Int</code>, <code>Long</code>, <code>Double</code>, etc. number Supports all standard numeric types. Use converter for tiny types. <code>bool</code> <code>Boolean</code> boolean Can wrap with custom converters. <code>array</code> <code>List&lt;T&gt;</code>, <code>Set&lt;T&gt;</code> array Requires an element converter. Supports both List and Set. <code>obj</code> nested object (data class) object Requires a converter for the object."},{"location":"short-field-functions/#whats-next","title":"\ud83d\udccc What's Next?","text":"<p>Explore more of Kondor\u2019s features:</p> <ul> <li>\ud83d\udcbb Converters Overview \u2013 an overview understanding how to work with Kondor converters</li> <li>\ud83d\udd01 Versioning the JSON \u2013 for evolving schemas</li> <li>\ud83d\udd24 Tiny Types (Value Objects) \u2013 for handling object you want to represent as a string or number</li> <li>\ud83d\udd24 Enums and Sealed Classes \u2013 for working with enums and sealed classes</li> <li>\ud83d\udee0 Field Functions \u2013 helper functions for defining fields in Kondor converters</li> <li>\ud83e\uddf3 Sealed Classes and Polymorphic JSON \u2013 handling polymorphic JSON with sealed classes</li> </ul>"},{"location":"tiny-types/","title":"Tiny Types (Value Objects)","text":"<p>In many Kotlin applications, we use tiny types \u2014 sometimes called value objects \u2014 to wrap primitive values with domain-specific meaning. For example, we might wrap a <code>String</code> in an <code>Email</code> class, or a <code>Double</code> in a <code>Price</code> class.</p> <p>This is a common technique for adding clarity and safety to your code, and is described well in this article by Darren Hobbs.</p> <p>Kotlin has first-class support for these kinds of types using inline value classes, which allow you to wrap a value while avoiding runtime overhead. Kondor builds on this concept by providing utilities to serialize and deserialize these types easily, avoiding the \"object\" overhead in the JSON.</p> <p>Kondor supports these types with minimal boilerplate. In this section, we\u2019ll look at a couple of strategies for working with tiny types.</p>"},{"location":"tiny-types/#the-default-approach","title":"\ud83e\uddf1 The Default Approach","text":"<p>If you don't define a custom converter for your tiny type, Kondor will serialize it as a regular object. For example:</p> <pre><code>class Email(val raw: String)\n\nobject JEmail : JAny&lt;Email&gt;() {\n    val raw by str(Email::raw)\n\n    override fun JsonNodeObject.deserializeOrThrow() =\n        Email(raw = +raw)\n}\n\ndata class User(val name: String, val email: Email)\n\nobject JUser : JAny&lt;User&gt;() {\n    val name by str(User::name)\n    val email by str(JEmail, User::email)\n\n    override fun JsonNodeObject.deserializeOrThrow() =\n        User(\n            name = +name,\n            email = +email\n        )\n}\n</code></pre>"},{"location":"tiny-types/#resulting-json","title":"Resulting JSON","text":"<pre><code>{\n  \"name\": \"Alice\",\n  \"email\": {\n    \"raw\": \"alice@example.com\"\n  }\n}\n</code></pre> <p>This works just fine, but adds unnecessary structure to the JSON \u2014 the <code>email</code> is just a string, so it makes sense to avoid wrapping it as an object. That\u2019s where <code>JStringRepresentable</code> or factory-style helpers come in.</p>"},{"location":"tiny-types/#using-jstringrepresentable","title":"\ud83d\udd27 Using <code>JStringRepresentable</code>","text":"<p>If your tiny type wraps a <code>String</code> but doesn't follow the wrapper class conventions, or if you need custom conversion logic, you can create a converter by subclassing <code>JStringRepresentable</code>.</p> <p>\ud83d\udd04 You can easily adapt this approach to work with other tiny type libraries such as values4k. As long as you can define a function to go from a string to your value object (e.g., from JSON) and back (e.g., to JSON), you can implement <code>JStringRepresentable</code> for any type.</p> <p><code>JStringRepresentable</code> is used to create a bidirectional mapping between a JSON string and your custom type. This is done by implementing two functions:</p> <ul> <li><code>cons</code> \u2014 a function that takes a <code>String</code> and returns an instance of your type.</li> <li><code>render</code> \u2014 a function that takes an instance of your type and returns a <code>String</code>.</li> </ul> <p>Together, these provide the two-way transformation between the JSON representation and the Kotlin object.</p>"},{"location":"tiny-types/#example","title":"Example","text":"<pre><code>class Email(val raw: String)\n\nobject JEmail : JStringRepresentable&lt;Email&gt;() {\n    override val cons: (String) -&gt; Email = ::Email\n    override val render: (Email) -&gt; String = { it.raw }\n}\n\n// Use it in a data class\ndata class User(val name: String, val email: Email)\n\nobject JUser : JAny&lt;User&gt;() {\n    val name by str(User::name)\n    val email by str(JEmail, User::email)\n\n    override fun JsonNodeObject.deserializeOrThrow() =\n        User(\n            name = +name,\n            email = +email\n        )\n}\n</code></pre>"},{"location":"tiny-types/#resulting-json_1","title":"Resulting JSON","text":"<pre><code>{\n  \"name\": \"Alice\",\n  \"email\": \"alice@example.com\"\n}\n</code></pre> <p>This approach gives you full control over how your tiny type is converted to and from strings, which can be helpful if you need to support legacy formats or add validation.</p>"},{"location":"tiny-types/#writing-your-own-converter-factories","title":"\ud83d\udd04 Writing Your Own Converter Factories","text":"<p>If you're using a consistent way to define your tiny types, you can create reusable factories to produce converters. This helps reduce duplication across many tiny types.</p> <p>Here\u2019s how you could define a helper converter for tiny types from values4k:</p> <pre><code>import dev.forkhandles.values.StringValue\n\n@JvmInline\nvalue class Email(override val value: String) : StringValue&lt;Email&gt;\n\nclass JStringValue&lt;T : StringValue&lt;T&gt;&gt;(\n    private val konstructor: (String) -&gt; T\n) : JStringRepresentable&lt;T&gt;() {\n    override val cons: (String) -&gt; T = konstructor\n    override val render: (T) -&gt; String = { it.value }\n}\n\nobject JEmail : JStringValue&lt;Email&gt;(::Email)\n\ndata class User(val name: String, val email: Email)\n\nobject JUser : JAny&lt;User&gt;() {\n    val name by str(User::name)\n    val email by stru(JEmail, User::email)\n\n    override fun JsonNodeObject.deserializeOrThrow() =\n        User(\n            name = +name,\n            email = +email\n        )\n}\n</code></pre>"},{"location":"tiny-types/#resulting-json_2","title":"Resulting JSON","text":"<pre><code>{\n  \"name\": \"Alice\",\n  \"email\": \"alice@example.com\"\n}\n</code></pre> <p>This lets you easily reuse a single converter factory for any of your value types that extend <code>StringValue</code>, keeping your JSON clean and your code DRY.</p>"},{"location":"tiny-types/#other-jrepresentable-classes","title":"\ud83d\udcda Other <code>J*Representable</code> Classes","text":"<p>In addition to <code>JStringRepresentable</code>, Kondor provides similar helpers for other primitive types. These include:</p> <ul> <li><code>JIntRepresentable&lt;T&gt;</code> \u2014 for types that wrap <code>Int</code></li> <li><code>JLongRepresentable&lt;T&gt;</code> \u2014 for types that wrap <code>Long</code></li> <li><code>JDoubleRepresentable&lt;T&gt;</code> \u2014 for types that wrap <code>Double</code></li> <li><code>JBoolRepresentable&lt;T&gt;</code> \u2014 for types that wrap <code>Boolean</code></li> <li><code>JFloatRepresentable&lt;T&gt;</code> \u2014 for types that wrap <code>Float</code></li> <li><code>JBigIntRepresentable&lt;T&gt;</code> \u2014 for types that wrap <code>BigInteger</code></li> </ul> <p>Each of these classes lets you define converters for tiny types by providing <code>cons</code> and <code>render</code> functions, just like <code>JStringRepresentable</code>.</p> <p>These are especially useful when working with domain primitives like <code>UserId</code>, <code>Price</code>, <code>Flag</code>, etc., that wrap core types while preserving type safety and clarity in your domain model.</p>"},{"location":"tiny-types/#whats-next","title":"\ud83d\udccc What's Next?","text":"<p>Explore more of Kondor\u2019s features:</p> <ul> <li>\ud83d\udcbb Converters Overview \u2013 an overview understanding how to work with Kondor converters</li> <li>\ud83d\udd01 Versioning the JSON \u2013 for evolving schemas</li> <li>\ud83d\udd24 Tiny Types (Value Objects) \u2013 for handling object you want to represent as a string or number</li> <li>\ud83d\udd24 Enums and Sealed Classes \u2013 for working with enums and sealed classes</li> <li>\ud83d\udee0 Field Functions \u2013 helper functions for defining fields in Kondor converters</li> <li>\ud83e\uddf3 Sealed Classes and Polymorphic JSON \u2013 handling polymorphic JSON with sealed classes</li> </ul>"},{"location":"versioned-converter/","title":"Versioning the JSON","text":"<p>Kondor-JSON supports versioned converters to help you manage evolving data structures and maintain backward compatibility with older JSON data formats.</p>"},{"location":"versioned-converter/#what-is-versionedconverter","title":"\ud83e\udded What is VersionedConverter?","text":"<p><code>VersionedConverter</code> is a base class you can extend to create version-aware converters. It allows mapping different versions of a data class from multiple JSON structures to a single unified Kotlin representation.</p> <p>To use it, you must override:</p> <pre><code>abstract fun converterForVersion(version: String): ObjectNodeConverter&lt;T&gt;?\nabstract val outputVersion: String?\n</code></pre> <p>These define how to select the appropriate deserializer based on the version string, and optionally how to mark which version to emit when serializing.</p> <p>By default, the version is written into the JSON as a field called <code>\"@version\"</code>. You can customize this by overriding:</p> <pre><code>open val versionFieldName: String = \"@version\"\n</code></pre> <p>You can also support multiple version strings mapping to the same converter to support legacy aliases or smooth upgrades.</p>"},{"location":"versioned-converter/#use-case","title":"\ud83c\udfaf Use Case","text":"<p>Let's say your model evolved like this:</p>"},{"location":"versioned-converter/#version-1","title":"Version 1:","text":"<pre><code>data class PersonV1(val name: String)\n</code></pre>"},{"location":"versioned-converter/#version-2","title":"Version 2:","text":"<pre><code>data class Person(val fullName: String, val age: Int)\n</code></pre> <p>You want to support reading <code>PersonV1</code> JSON while using <code>Person</code> in your codebase.</p>"},{"location":"versioned-converter/#setup","title":"\ud83e\uddf1 Setup","text":"<pre><code>data class Person(val fullName: String, val age: Int)\n\nobject PersonConverterV1 : JConverterObject&lt;Person&gt;() {\n    private val name by str()\n\n    override fun JsonNodeObject.deserializeOrThrow(): Person =\n        Person(\n            fullName = +name,\n            age = 0 // default age\n        )\n}\n\nobject PersonConverterV2 : JConverterObject&lt;Person&gt;() {\n    private val fullName by str()\n    private val age by int()\n\n    override fun JsonNodeObject.deserializeOrThrow(): Person =\n        Person(\n            fullName = +fullName,\n            age = +age\n        )\n}\n\nobject VersionedPerson : VersionedConverter&lt;Person&gt;() {\n    override fun converterForVersion(version: String) = when (version) {\n        \"1\" -&gt; PersonConverterV1\n        \"2\" -&gt; PersonConverterV2\n        else -&gt; null\n    }\n\n    override val outputVersion = \"2\"\n}\n</code></pre>"},{"location":"versioned-converter/#example-json-output","title":"\ud83e\uddea Example JSON Output","text":"<p>When serializing a <code>Person</code>, Kondor will automatically include the version:</p> <pre><code>{\n  \"@version\": \"2\",\n  \"fullName\": \"Alice\",\n  \"age\": 30\n}\n</code></pre>"},{"location":"versioned-converter/#reading-legacy-json","title":"Reading Legacy JSON","text":"<pre><code>val legacyJson = JsonParser.parse('{\"@version\":\"1\", \"name\":\"Alice\"}')\nval person = VersionedPerson.fromJson(legacyJson)\n</code></pre> <p>This results in:</p> <pre><code>Person(fullName = \"Alice\", age = 0)\n</code></pre>"},{"location":"versioned-converter/#versionmapconverter","title":"\ud83d\udea6 VersionMapConverter","text":"<p>If you prefer a simpler way to manage versioned converters, Kondor provides a convenient helper class: <code>VersionMapConverter</code>.</p> <p>Instead of overriding methods, you just pass a version-to-converter map to the constructor. The first entry in the map is used as the output version when serializing.</p>"},{"location":"versioned-converter/#setup_1","title":"\ud83d\udd27 Setup","text":"<pre><code>object VersionedPerson2 : VersionMapConverter&lt;Person&gt;(\n    versionConverters = mapOf(\n        \"2\" to PersonConverterV2,\n        \"1\" to PersonConverterV1\n    )\n)\n</code></pre> <p>This achieves the same behavior as the manual implementation using <code>VersionedConverter</code>, but with less boilerplate.</p> <ul> <li>When reading JSON, the <code>@version</code> field (by default) determines which converter is used.</li> <li>When writing JSON, the first entry (<code>\"2\"</code> here) is assumed to be the current version.</li> </ul>"},{"location":"versioned-converter/#output-json","title":"\ud83e\uddea Output JSON","text":"<pre><code>{\n  \"@version\": \"2\",\n  \"fullName\": \"Alice\",\n  \"age\": 30\n}\n</code></pre>"},{"location":"versioned-converter/#handling-unversioned-json","title":"\ud83d\udd75\ufe0f Handling Unversioned JSON","text":"<p>Sometimes you only start versioning after data has already been serialized without any version markers. In this case, Kondor allows you to define a fallback strategy using <code>unversionedConverters</code>.</p> <p>These converters are tried in order until one successfully parses the input JSON.</p>"},{"location":"versioned-converter/#using-with-versionmapconverter","title":"Using with <code>VersionMapConverter</code>","text":"<pre><code>object VersionedPerson3 : VersionMapConverter&lt;Person&gt;(\n    versionConverters = mapOf(\n        \"2\" to PersonConverterV2,\n        \"1\" to PersonConverterV1\n    ),\n    override val unversionedConverters: List&lt;ObjectNodeConverter&lt;Person&gt;&gt; = \n      listOf(ReallyOldPersonConverter, EvenOlderPersonConverter)\n)\n</code></pre>"},{"location":"versioned-converter/#using-with-versionedconverter","title":"Using with <code>VersionedConverter</code>","text":"<pre><code>object VersionedPerson4 : VersionedConverter&lt;Person&gt;() {\n    override fun converterForVersion(version: String) = when (version) {\n        \"1\" -&gt; PersonConverterV1\n        \"2\" -&gt; PersonConverterV2\n        else -&gt; null\n    }\n\n    override val outputVersion = \"2\"\n\n    override val unversionedConverters: List&lt;ObjectNodeConverter&lt;Person&gt;&gt; = \n      listOf(ReallyOldPersonConverter, EvenOlderPersonConverter)\n}\n</code></pre> <p>This is useful when handling legacy data that doesn\u2019t include version markers but still needs to be parsed reliably.</p>"},{"location":"versioned-converter/#using-only-unversioned-converters","title":"\ud83e\uddea Using Only Unversioned Converters","text":"<p>You can also use <code>VersionMapConverter</code> without providing any versioned converter mappings at all \u2014 just a list of <code>unversionedConverters</code>. This is useful when you're dealing with legacy JSON that never included versioning information.</p> <pre><code>object LegacyPersonSupport : VersionMapConverter&lt;Person&gt;(\n    unversionedConverters = listOf(\n        ReallyOldPersonConverter,\n        EvenOlderPersonConverter\n    )\n)\n</code></pre> <p>In this setup:</p> <ul> <li>There is no need for a <code>@version</code> field in the JSON.</li> <li>Kondor will try each converter in order until one successfully parses the object.</li> <li>This allows you to incrementally introduce versioning without needing to rewrite all your old data.</li> </ul>"},{"location":"versioned-converter/#tip","title":"\ud83d\udca1 Tip","text":"<p>Versioning strategy can be:</p> <ul> <li>File-based (metadata stored separately)</li> <li>Embedded in the JSON (e.g., a <code>@version</code> field, which is the default in Kondor)</li> </ul> <p>You can also support multiple version strings mapping to the same converter to allow for legacy compatibility or aliases like <code>\"latest\"</code> or <code>\"2.0\"</code>.</p>"},{"location":"versioned-converter/#whats-next","title":"\ud83d\udccc What's Next?","text":"<p>Explore more of Kondor\u2019s features:</p> <ul> <li>\ud83d\udcbb Converters Overview \u2013 an overview understanding how to work with Kondor converters</li> <li>\ud83d\udd01 Versioning the JSON \u2013 for evolving schemas</li> <li>\ud83d\udd24 Tiny Types (Value Objects) \u2013 for handling object you want to represent as a string or number</li> <li>\ud83d\udd24 Enums and Sealed Classes \u2013 for working with enums and sealed classes</li> <li>\ud83d\udee0 Field Functions \u2013 helper functions for defining fields in Kondor converters</li> <li>\ud83e\uddf3 Sealed Classes and Polymorphic JSON \u2013 handling polymorphic JSON with sealed classes</li> </ul>"}]}
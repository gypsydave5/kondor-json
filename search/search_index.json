{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Kondor-JSON","text":"<p>Welcome to Kondor-JSON, a Kotlin-first JSON serialization library that emphasizes type-safety, composability, and clarity.</p>"},{"location":"#what-is-kondor-json","title":"\ud83d\udd0d What is Kondor-JSON?","text":"<p>Kondor-JSON allows you to define type-safe, bidirectional mappings between your Kotlin data classes and JSON documents using a flexible DSL. It avoids reflection and favors a functional style to keep your data transformations explicit and testable.</p>"},{"location":"#features","title":"\ud83d\ude80 Features","text":"<ul> <li>Type-safe JSON serialization/deserialization</li> <li>Fully customizable converters</li> <li>Versioned converters for backward compatibility</li> <li>String representable support for enums and sealed classes</li> <li>No reflection, works in Kotlin Multiplatform</li> </ul>"},{"location":"#example","title":"\ud83d\udee0\ufe0f Example","text":"<pre><code>import com.ubertob.kondor.json.*\nimport com.ubertob.kondor.json.jvalue.*\n\ndata class Person(val name: String, val age: Int)\n\nobject PersonConverter : JConverterObject&lt;Person&gt;() {\n    private val name by str()\n    private val age by int()\n\n    override fun JsonNodeObject.deserializeOrThrow(): Person =\n        Person(\n            name = +name,\n            age = +age\n        )\n\n    override fun Person.serialize(): JsonNodeObject =\n        jsonObj {\n            name of it.name\n            age of it.age\n        }\n}\n\nfun main() {\n    val person = Person(\"Alice\", 30)\n    val json = PersonConverter.toJsonStr(person)\n    println(json)\n    println(PersonConverter.fromJsonStr(json))\n}\n</code></pre>"},{"location":"#next-steps","title":"\ud83d\udcda Next Steps","text":"<ul> <li>Getting Started</li> <li>Versioned Converters</li> <li>API Reference</li> </ul>"},{"location":"enums-and-sealed/","title":"Enums and Sealed Classes","text":"<p>Kondor-JSON offers seamless support for Kotlin enums, providing both a default serialization strategy and the ability to customize the behavior using <code>JEnumClass</code>.</p>"},{"location":"enums-and-sealed/#enums","title":"\ud83d\udd24 Enums","text":""},{"location":"enums-and-sealed/#default-enum-serialization","title":"Default Enum Serialization","text":"<p>The easiest way to serialize an enum in Kondor is by using <code>JEnumClass</code>, which provides a sensible default: enum values are mapped to their <code>.name</code> strings in JSON.</p> <pre><code>enum class Colour { Red, Green, Blue }\n\nobject JColour : JEnumClass&lt;Colour&gt;(Colour::class)\n</code></pre> <p>You can then use this converter in your data classes:</p> <pre><code>data class Paint(val shade: Colour)\n\nobject JPaint : JAny&lt;Paint&gt;() {\n    val shade by JColour(Paint::shade)\n\n    override fun JsonNodeObject.deserializeOrThrow() =\n        Paint(+shade)\n}\n</code></pre> <p>This will serialize a <code>Paint</code> object to:</p> <pre><code>{ \"shade\": \"Red\" }\n</code></pre>"},{"location":"enums-and-sealed/#customizing-enum-representation","title":"Customizing Enum Representation","text":"<p>If you'd like to represent enums using custom strings (e.g., abbreviations), you can subclass <code>JEnumClass</code> and override the <code>render</code> and <code>cons</code> methods.</p> <pre><code>enum class Status { Active, Inactive, Pending }\n\nobject JStatus : JEnumClass&lt;Status&gt;(Status::class) {\n    override val render: (Status) -&gt; String = {\n        when (it) {\n            Status.Active -&gt; \"A\"\n            Status.Inactive -&gt; \"I\"\n            Status.Pending -&gt; \"P\"\n        }\n    }\n\n    override val cons: (String) -&gt; Status = {\n        when (it) {\n            \"A\", \"Active\" -&gt; Status.Active\n            \"I\", \"Inactive\" -&gt; Status.Inactive\n            \"P\", \"Pending\" -&gt; Status.Pending\n            else -&gt; error(\"Unknown status: $it\")\n        }\n    }\n}\n</code></pre> <p>This allows the following round-trip:</p> <pre><code>{ \"status\": \"A\" }\n</code></pre> <p>It also enables backwards compatibility with older JSON representations. For example, if earlier versions of your application used full enum names like \"Active\", and you've now switched to abbreviations like \"A\", the <code>cons</code> function can support both:</p> <ul> <li>\"Active\" and \"A\" will both deserialize to <code>Status.Active</code></li> <li>\"Inactive\" and \"I\" to <code>Status.Inactive</code></li> <li>\"Pending\" and \"P\" to <code>Status.Pending</code></li> </ul> <p>This makes it easy to evolve your enum serialization format over time without breaking compatibility with existing data.</p> <p>The custom converter can now be used just like any other in a <code>JAny</code> definition.</p>"},{"location":"enums-and-sealed/#sealed-classes","title":"\ud83e\uddf1 Sealed Classes","text":"<p>Kondor makes it easy to work with sealed class hierarchies by using the <code>JSealed</code> converter. This allows you to encode and decode subclasses with a discriminator field that indicates which type is being used.</p>"},{"location":"enums-and-sealed/#example","title":"Example","text":"<pre><code>sealed class Animal\n\ndata class Dog(val name: String) : Animal()\ndata class Cat(val lives: Int) : Animal()\n</code></pre> <p>You define converters for each concrete subclass:</p> <pre><code>object JDog : JAny&lt;Dog&gt;() {\n    val name by str(Dog::name)\n\n    override fun JsonNodeObject.deserializeOrThrow() =\n        Dog(+name)\n}\n\nobject JCat : JAny&lt;Cat&gt;() {\n    val lives by num(Cat::lives)\n\n    override fun JsonNodeObject.deserializeOrThrow() =\n        Cat(+lives)\n}\n</code></pre> <p>Then, define a <code>JSealed</code> converter for the sealed class. To do this, you need to override two things:</p> <ol> <li><code>extractTypeName(obj: T)</code>: a function that returns a string discriminator based on the type of the object.</li> <li><code>subConverters</code>: a map that links type names to their respective converters.</li> </ol> <pre><code>object JAnimal : JSealed&lt;Animal&gt;() {\n    override fun extractTypeName(obj: Animal): String = when (obj) {\n        is Dog -&gt; \"dog\"\n        is Cat -&gt; \"cat\"\n    }\n\n    override val subConverters: Map&lt;String, ObjectNodeConverter&lt;out Animal&gt;&gt; = mapOf(\n        \"dog\" to JDog,\n        \"cat\" to JCat\n    )\n}\n</code></pre> <p>This will produce JSON like:</p> <pre><code>{ \"_type\": \"dog\", \"name\": \"Fido\" }\n</code></pre> <p>When deserializing, Kondor uses the value of the <code>\"_type\"</code> property to determine which converter to use. This makes sealed class hierarchies both extensible and safe to work with in a polymorphic way.</p> <p>By default, the discriminator property is named <code>_type</code>, but you can customize this by overriding:</p> <pre><code>override val discriminatorFieldName: String = \"type\"\n</code></pre> <p>As with enums, you can also map multiple different type strings to the same converter. This allows older JSON data to remain compatible even after renaming or restructuring the Kotlin class hierarchy. For instance:</p> <pre><code>override val subConverters = mapOf(\n    \"dog\" to JDog,\n    \"canine\" to JDog, // legacy support\n    \"cat\" to JCat\n)\n</code></pre> <p>This means both <code>{ \"_type\": \"dog\" }</code> and <code>{ \"_type\": \"canine\" }</code> will deserialize using <code>JDog</code>. This makes it easier to evolve sealed class hierarchies over time without breaking old clients.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to Kondor-JSON! This guide will help you get up and running quickly with real examples based on the actual API.</p>"},{"location":"getting-started/#installation","title":"\ud83d\udd27 Installation","text":"<p>Add Kondor-JSON to your <code>build.gradle.kts</code>:</p> <pre><code>dependencies {\n    implementation(\"com.ubertob.kondor:kondor-json:&lt;latest-version&gt;\")\n}\n</code></pre> <p>\ud83d\udce6 Check Maven Central for the latest version.</p>"},{"location":"getting-started/#core-concepts","title":"\ud83e\udde0 Core Concepts","text":"<p>Kondor represents JSON through a strongly-typed model:</p> <ul> <li><code>JAny</code> \u2014 the root type for all JSON values</li> <li><code>JString</code>, <code>JInt</code>, <code>JBool</code>, etc. \u2014 primitive value types</li> <li><code>JObj</code>, <code>JArray</code> \u2014 container types</li> <li><code>JConverter&lt;T&gt;</code> \u2014 bridges Kotlin types and JSON representations</li> </ul>"},{"location":"getting-started/#real-world-example","title":"\u2705 Real-World Example","text":"<pre><code>import com.ubertob.kondor.json.*\nimport com.ubertob.kondor.json.jvalue.*\n\ndata class Person(val name: String, val age: Int)\n\nobject PersonConverter : JConverterObject&lt;Person&gt;() {\n    private val name by str()\n    private val age by int()\n\n    override fun JsonNodeObject.deserializeOrThrow(): Person =\n        Person(\n            name = +name,\n            age = +age\n        )\n\n    override fun Person.serialize(): JsonNodeObject =\n        jsonObj {\n            name of it.name\n            age of it.age\n        }\n}\n\nfun main() {\n    val person = Person(\"Alice\", 30)\n    val json = PersonConverter.toJsonStr(person)\n    println(json)\n    println(PersonConverter.fromJsonStr(json))\n}\n</code></pre>"},{"location":"getting-started/#output","title":"Output:","text":"<pre><code>{\"name\":\"Alice\",\"age\":30}\nPerson(name=Alice, age=30)\n</code></pre>"},{"location":"getting-started/#next-steps","title":"\u23ed\ufe0f Next Steps","text":"<ul> <li>Learn about VersionedConverter for schema evolution</li> <li>Browse API Reference</li> <li>See how to use JStringRepresentable</li> </ul>"},{"location":"tiny-types/","title":"Tiny Types (Value Objects)","text":"<p>In many Kotlin applications, we use tiny types \u2014 sometimes called value objects \u2014 to wrap primitive values with domain-specific meaning. For example, we might wrap a <code>String</code> in an <code>Email</code> class, or a <code>Double</code> in a <code>Price</code> class.</p> <p>This is a common technique for adding clarity and safety to your code, and is described well in this article by Darren Hobbs.</p> <p>Kotlin has first-class support for these kinds of types using inline value classes, which allow you to wrap a value while avoiding runtime overhead. Kondor builds on this concept by providing utilities to serialize and deserialize these types easily, avoiding the \"object\" overhead in the JSON.</p> <p>Kondor supports these types with minimal boilerplate. In this section, we\u2019ll look at a couple of strategies for working with tiny types.</p>"},{"location":"tiny-types/#the-default-approach","title":"\ud83e\uddf1 The Default Approach","text":"<p>If you don't define a custom converter for your tiny type, Kondor will serialize it as a regular object. For example:</p> <pre><code>class Email(val raw: String)\n\nobject JEmail : JAny&lt;Email&gt;() {\n    val raw by str(Email::raw)\n\n    override fun JsonNodeObject.deserializeOrThrow() =\n        Email(raw = +raw)\n}\n\ndata class User(val name: String, val email: Email)\n\nobject JUser : JAny&lt;User&gt;() {\n    val name by str(User::name)\n    val email by str(JEmail, User::email)\n\n    override fun JsonNodeObject.deserializeOrThrow() =\n        User(\n            name = +name,\n            email = +email\n        )\n}\n</code></pre>"},{"location":"tiny-types/#resulting-json","title":"Resulting JSON","text":"<pre><code>{\n  \"name\": \"Alice\",\n  \"email\": {\n    \"raw\": \"alice@example.com\"\n  }\n}\n</code></pre> <p>This works just fine, but adds unnecessary structure to the JSON \u2014 the <code>email</code> is just a string, so it makes sense to avoid wrapping it as an object. That\u2019s where <code>JStringRepresentable</code> or factory-style helpers come in.</p>"},{"location":"tiny-types/#using-jstringrepresentable","title":"\ud83d\udd27 Using <code>JStringRepresentable</code>","text":"<p>If your tiny type wraps a <code>String</code> but doesn't follow the wrapper class conventions, or if you need custom conversion logic, you can create a converter by subclassing <code>JStringRepresentable</code>.</p> <p>\ud83d\udd04 You can easily adapt this approach to work with other tiny type libraries such as values4k. As long as you can define a function to go from a string to your value object (e.g., from JSON) and back (e.g., to JSON), you can implement <code>JStringRepresentable</code> for any type.</p> <p><code>JStringRepresentable</code> is used to create a bidirectional mapping between a JSON string and your custom type. This is done by implementing two functions:</p> <ul> <li><code>cons</code> \u2014 a function that takes a <code>String</code> and returns an instance of your type.</li> <li><code>render</code> \u2014 a function that takes an instance of your type and returns a <code>String</code>.</li> </ul> <p>Together, these provide the two-way transformation between the JSON representation and the Kotlin object.</p>"},{"location":"tiny-types/#example","title":"Example","text":"<pre><code>class Email(val raw: String)\n\nobject JEmail : JStringRepresentable&lt;Email&gt;() {\n    override val cons: (String) -&gt; Email = ::Email\n    override val render: (Email) -&gt; String = { it.raw }\n}\n\n// Use it in a data class\ndata class User(val name: String, val email: Email)\n\nobject JUser : JAny&lt;User&gt;() {\n    val name by str(User::name)\n    val email by str(JEmail, User::email)\n\n    override fun JsonNodeObject.deserializeOrThrow() =\n        User(\n            name = +name,\n            email = +email\n        )\n}\n</code></pre>"},{"location":"tiny-types/#resulting-json_1","title":"Resulting JSON","text":"<pre><code>{\n  \"name\": \"Alice\",\n  \"email\": \"alice@example.com\"\n}\n</code></pre> <p>This approach gives you full control over how your tiny type is converted to and from strings, which can be helpful if you need to support legacy formats or add validation.</p>"},{"location":"tiny-types/#writing-your-own-converter-factories","title":"\ud83d\udd04 Writing Your Own Converter Factories","text":"<p>If you're using a consistent way to define your tiny types, you can create reusable factories to produce converters. This helps reduce duplication across many tiny types.</p> <p>Here\u2019s how you could define a helper converter for tiny types from values4k:</p> <pre><code>import dev.forkhandles.values.StringValue\n\n@JvmInline\nvalue class Email(override val value: String) : StringValue&lt;Email&gt;\n\nclass JStringValue&lt;T : StringValue&lt;T&gt;&gt;(\n    private val konstructor: (String) -&gt; T\n) : JStringRepresentable&lt;T&gt;() {\n    override val cons: (String) -&gt; T = konstructor\n    override val render: (T) -&gt; String = { it.value }\n}\n\nobject JEmail : JStringValue&lt;Email&gt;(::Email)\n\ndata class User(val name: String, val email: Email)\n\nobject JUser : JAny&lt;User&gt;() {\n    val name by str(User::name)\n    val email by stru(JEmail, User::email)\n\n    override fun JsonNodeObject.deserializeOrThrow() =\n        User(\n            name = +name,\n            email = +email\n        )\n}\n</code></pre>"},{"location":"tiny-types/#resulting-json_2","title":"Resulting JSON","text":"<pre><code>{\n  \"name\": \"Alice\",\n  \"email\": \"alice@example.com\"\n}\n</code></pre> <p>This lets you easily reuse a single converter factory for any of your value types that extend <code>StringValue</code>, keeping your JSON clean and your code DRY.</p>"},{"location":"tiny-types/#other-jrepresentable-classes","title":"\ud83d\udcda Other <code>J*Representable</code> Classes","text":"<p>In addition to <code>JStringRepresentable</code>, Kondor provides similar helpers for other primitive types. These include:</p> <ul> <li><code>JIntRepresentable&lt;T&gt;</code> \u2014 for types that wrap <code>Int</code></li> <li><code>JLongRepresentable&lt;T&gt;</code> \u2014 for types that wrap <code>Long</code></li> <li><code>JDoubleRepresentable&lt;T&gt;</code> \u2014 for types that wrap <code>Double</code></li> <li><code>JBoolRepresentable&lt;T&gt;</code> \u2014 for types that wrap <code>Boolean</code></li> <li><code>JFloatRepresentable&lt;T&gt;</code> \u2014 for types that wrap <code>Float</code></li> <li><code>JBigIntRepresentable&lt;T&gt;</code> \u2014 for types that wrap <code>BigInteger</code></li> </ul> <p>Each of these classes lets you define converters for tiny types by providing <code>cons</code> and <code>render</code> functions, just like <code>JStringRepresentable</code>.</p> <p>These are especially useful when working with domain primitives like <code>UserId</code>, <code>Price</code>, <code>Flag</code>, etc., that wrap core types while preserving type safety and clarity in your domain model.</p>"},{"location":"versioned-converter/","title":"Versioning the JSON","text":"<p>Kondor-JSON supports versioned converters to help you manage evolving data structures and maintain backward compatibility with older JSON data formats.</p>"},{"location":"versioned-converter/#what-is-versionedconverter","title":"\ud83e\udded What is VersionedConverter?","text":"<p><code>VersionedConverter</code> is a base class you can extend to create version-aware converters. It allows mapping different versions of a data class from multiple JSON structures to a single unified Kotlin representation.</p> <p>To use it, you must override:</p> <pre><code>abstract fun converterForVersion(version: String): ObjectNodeConverter&lt;T&gt;?\nabstract val outputVersion: String?\n</code></pre> <p>These define how to select the appropriate deserializer based on the version string, and optionally how to mark which version to emit when serializing.</p> <p>By default, the version is written into the JSON as a field called <code>\"@version\"</code>. You can customize this by overriding:</p> <pre><code>open val versionFieldName: String = \"@version\"\n</code></pre> <p>You can also support multiple version strings mapping to the same converter to support legacy aliases or smooth upgrades.</p>"},{"location":"versioned-converter/#use-case","title":"\ud83c\udfaf Use Case","text":"<p>Let's say your model evolved like this:</p>"},{"location":"versioned-converter/#version-1","title":"Version 1:","text":"<pre><code>data class PersonV1(val name: String)\n</code></pre>"},{"location":"versioned-converter/#version-2","title":"Version 2:","text":"<pre><code>data class Person(val fullName: String, val age: Int)\n</code></pre> <p>You want to support reading <code>PersonV1</code> JSON while using <code>Person</code> in your codebase.</p>"},{"location":"versioned-converter/#setup","title":"\ud83e\uddf1 Setup","text":"<pre><code>data class Person(val fullName: String, val age: Int)\n\nobject PersonConverterV1 : JConverterObject&lt;Person&gt;() {\n    private val name by str()\n\n    override fun JsonNodeObject.deserializeOrThrow(): Person =\n        Person(\n            fullName = +name,\n            age = 0 // default age\n        )\n}\n\nobject PersonConverterV2 : JConverterObject&lt;Person&gt;() {\n    private val fullName by str()\n    private val age by int()\n\n    override fun JsonNodeObject.deserializeOrThrow(): Person =\n        Person(\n            fullName = +fullName,\n            age = +age\n        )\n}\n\nobject VersionedPerson : VersionedConverter&lt;Person&gt;() {\n    override fun converterForVersion(version: String) = when (version) {\n        \"1\" -&gt; PersonConverterV1\n        \"2\" -&gt; PersonConverterV2\n        else -&gt; null\n    }\n\n    override val outputVersion = \"2\"\n}\n</code></pre>"},{"location":"versioned-converter/#example-json-output","title":"\ud83e\uddea Example JSON Output","text":"<p>When serializing a <code>Person</code>, Kondor will automatically include the version:</p> <pre><code>{\n  \"@version\": \"2\",\n  \"fullName\": \"Alice\",\n  \"age\": 30\n}\n</code></pre>"},{"location":"versioned-converter/#reading-legacy-json","title":"Reading Legacy JSON","text":"<pre><code>val legacyJson = JsonParser.parse('{\"@version\":\"1\", \"name\":\"Alice\"}')\nval person = VersionedPerson.fromJson(legacyJson)\n</code></pre> <p>This results in:</p> <pre><code>Person(fullName = \"Alice\", age = 0)\n</code></pre>"},{"location":"versioned-converter/#versionmapconverter","title":"\ud83d\udea6 VersionMapConverter","text":"<p>If you prefer a simpler way to manage versioned converters, Kondor provides a convenient helper class: <code>VersionMapConverter</code>.</p> <p>Instead of overriding methods, you just pass a version-to-converter map to the constructor. The first entry in the map is used as the output version when serializing.</p>"},{"location":"versioned-converter/#setup_1","title":"\ud83d\udd27 Setup","text":"<pre><code>object VersionedPerson2 : VersionMapConverter&lt;Person&gt;(\n    versionConverters = mapOf(\n        \"2\" to PersonConverterV2,\n        \"1\" to PersonConverterV1\n    )\n)\n</code></pre> <p>This achieves the same behavior as the manual implementation using <code>VersionedConverter</code>, but with less boilerplate.</p> <ul> <li>When reading JSON, the <code>@version</code> field (by default) determines which converter is used.</li> <li>When writing JSON, the first entry (<code>\"2\"</code> here) is assumed to be the current version.</li> </ul>"},{"location":"versioned-converter/#output-json","title":"\ud83e\uddea Output JSON","text":"<pre><code>{\n  \"@version\": \"2\",\n  \"fullName\": \"Alice\",\n  \"age\": 30\n}\n</code></pre>"},{"location":"versioned-converter/#handling-unversioned-json","title":"\ud83d\udd75\ufe0f Handling Unversioned JSON","text":"<p>Sometimes you only start versioning after data has already been serialized without any version markers. In this case, Kondor allows you to define a fallback strategy using <code>unversionedConverters</code>.</p> <p>These converters are tried in order until one successfully parses the input JSON.</p>"},{"location":"versioned-converter/#using-with-versionmapconverter","title":"Using with <code>VersionMapConverter</code>","text":"<pre><code>object VersionedPerson3 : VersionMapConverter&lt;Person&gt;(\n    versionConverters = mapOf(\n        \"2\" to PersonConverterV2,\n        \"1\" to PersonConverterV1\n    ),\n    override val unversionedConverters: List&lt;ObjectNodeConverter&lt;Person&gt;&gt; = \n      listOf(ReallyOldPersonConverter, EvenOlderPersonConverter)\n)\n</code></pre>"},{"location":"versioned-converter/#using-with-versionedconverter","title":"Using with <code>VersionedConverter</code>","text":"<pre><code>object VersionedPerson4 : VersionedConverter&lt;Person&gt;() {\n    override fun converterForVersion(version: String) = when (version) {\n        \"1\" -&gt; PersonConverterV1\n        \"2\" -&gt; PersonConverterV2\n        else -&gt; null\n    }\n\n    override val outputVersion = \"2\"\n\n    override val unversionedConverters: List&lt;ObjectNodeConverter&lt;Person&gt;&gt; = \n      listOf(ReallyOldPersonConverter, EvenOlderPersonConverter)\n}\n</code></pre> <p>This is useful when handling legacy data that doesn\u2019t include version markers but still needs to be parsed reliably.</p>"},{"location":"versioned-converter/#using-only-unversioned-converters","title":"\ud83e\uddea Using Only Unversioned Converters","text":"<p>You can also use <code>VersionMapConverter</code> without providing any versioned converter mappings at all \u2014 just a list of <code>unversionedConverters</code>. This is useful when you're dealing with legacy JSON that never included versioning information.</p> <pre><code>object LegacyPersonSupport : VersionMapConverter&lt;Person&gt;(\n    unversionedConverters = listOf(\n        ReallyOldPersonConverter,\n        EvenOlderPersonConverter\n    )\n)\n</code></pre> <p>In this setup:</p> <ul> <li>There is no need for a <code>@version</code> field in the JSON.</li> <li>Kondor will try each converter in order until one successfully parses the object.</li> <li>This allows you to incrementally introduce versioning without needing to rewrite all your old data.</li> </ul>"},{"location":"versioned-converter/#tip","title":"\ud83d\udca1 Tip","text":"<p>Versioning strategy can be:</p> <ul> <li>File-based (metadata stored separately)</li> <li>Embedded in the JSON (e.g., a <code>@version</code> field, which is the default in Kondor)</li> </ul> <p>You can also support multiple version strings mapping to the same converter to allow for legacy compatibility or aliases like <code>\"latest\"</code> or <code>\"2.0\"</code>.</p>"},{"location":"versioned-converter/#related","title":"\ud83d\udd17 Related","text":"<ul> <li>Getting Started</li> <li>JStringRepresentable</li> </ul>"}]}